# MapStruct

This API contains functions that automatically map between two Java Beans. With MapStruct, we only need to create the
interface, and the library will automatically create a concrete implementation during compile time.

## MapStruct and Transfer Object Pattern

For most applications, you’ll notice a lot of boilerplate code converting POJOs to other POJOs.

For example, a common type of conversion happens between persistence-backed entities and DTOs that go out to the
client-side.

So, that is the problem that MapStruct solves: Manually creating bean mappers is time-consuming. But the library **can
generate bean mapper classes automatically.**

# Defining Mapper

To create a mapper simply define a Java interface with the required mapping method(s) and annotate it with the
`org.mapstruct.Mapper` annotation:

```java

@Mapper
public interface CarMapper {

    @Mapping(target = "manufacturer", source = "make")
    @Mapping(target = "seatCount", source = "numberOfSeats")
    CarDto carToCarDto(Car car);

    @Mapping(target = "fullName", source = "name")
    PersonDto personToPersonDto(Person person);
}
```

The @Mapper annotation causes the MapStruct code generator to create an implementation of the CarMapper interface during
build-time.

In the generated method implementations all readable properties from the source type (e.g. Car) will be copied into the
corresponding property in the target type (e.g. CarDto):

- When a property has the same name as its target entity counterpart, it will be mapped implicitly.
- When a property has a different name in the target entity, its name can be specified via the @Mapping annotation.

## Code Generated by MapStruct

```java
// GENERATED CODE
public class CarMapperImpl implements CarMapper {

    @Override
    public CarDto carToCarDto(Car car) {
        if (car == null) {
            return null;
        }

        CarDto carDto = new CarDto();

        if (car.getFeatures() != null) {
            carDto.setFeatures(new ArrayList<String>(car.getFeatures()));
        }
        carDto.setManufacturer(car.getMake());
        carDto.setSeatCount(car.getNumberOfSeats());
        carDto.setDriver(personToPersonDto(car.getDriver()));
        carDto.setPrice(String.valueOf(car.getPrice()));
        if (car.getCategory() != null) {
            carDto.setCategory(car.getCategory().toString());
        }
        carDto.setEngine(engineToEngineDto(car.getEngine()));

        return carDto;
    }

    @Override
    public PersonDto personToPersonDto(Person person) {
        //...
    }

    private EngineDto engineToEngineDto(Engine engine) {
        if (engine == null) {
            return null;
        }

        EngineDto engineDto = new EngineDto();

        engineDto.setHorsePower(engine.getHorsePower());
        engineDto.setFuel(engine.getFuel());

        return engineDto;
    }
}
```

The general philosophy of MapStruct is to generate code which looks as much as possible as if you had written it
yourself from hand. In particular this means that the values are copied from source to target by plain getter/setter
invocations instead of reflection or similar.

As the example shows the generated code takes into account any name mappings specified via @Mapping. If the type of a
mapped attribute is different in source and target entity, MapStruct will either apply an automatic conversion (as e.g.
for the price property, see also Implicit type conversions) or optionally invoke / create another mapping method (as
e.g. for the driver / engine property, see also Mapping object references). MapStruct will only create a new mapping
method if and only if the source and target property are properties of a Bean and they themselves are Beans or simple
properties. i.e. they are not Collection or Map type properties.

Collection-typed attributes with the same element type will be copied by creating a new instance of the target
collection type containing the elements from the source property. For collection-typed attributes with different element
types each element will be mapped individually and added to the target collection (see Mapping collections).

MapStruct takes all public properties of the source and target types into account. This includes properties declared on
super-types.

## Mapping Composition (experimental)

MapStruct supports the use of meta annotations. The @Mapping annotation supports now @Target with
ElementType#ANNOTATION_TYPE in addition to ElementType#METHOD. This allows @Mapping to be used on other (user defined)
annotations for re-use purposes. For example:

```java

@Retention(RetentionPolicy.CLASS)
@Mapping(target = "id", ignore = true)
@Mapping(target = "creationDate", expression = "java(new java.util.Date())")
@Mapping(target = "name", source = "groupName")
public @interface ToEntity {
}
```

Can be used to characterise an Entity without the need to have a common base type. For instance, ShelveEntity and
BoxEntity do not share a common base type in the StorageMapper below.

```java

@Mapper
public interface StorageMapper {

    StorageMapper INSTANCE = Mappers.getMapper(StorageMapper.class);

    @ToEntity
    @Mapping(target = "weightLimit", source = "maxWeight")
    ShelveEntity map(ShelveDto source);

    @ToEntity
    @Mapping(target = "label", source = "designation")
    BoxEntity map(BoxDto source);
}
```

Still, they do have some properties in common. The @ToEntity assumes both target beans ShelveEntity and BoxEntity have
properties: "id", "creationDate" and "name". It furthermore assumes that the source beans ShelveDto and BoxDto always
have a property "groupName". This concept is also known as "duck-typing". In other words, if it quacks like duck, walks
like a duck its probably a duck.

This feature is still experimental. Error messages are not mature yet: the method on which the problem occurs is
displayed, as well as the concerned values in the @Mapping annotation. However, the composition aspect is not visible.
The messages are "as if" the @Mapping would be present on the concerned method directly. Therefore, the user should use
this feature with care, especially when uncertain when a property is always present.

## Adding custom methods to mappers

In some cases it can be required to manually implement a specific mapping from one type to another which can’t be
generated by MapStruct. One way to handle this is to implement the custom method on another class which then is used by
mappers generated by MapStruct

Alternatively, when using Java 8 or later, you can implement custom methods directly in a mapper interface as default
methods. The generated code will invoke the default methods if the argument and return types match.

As an example let’s assume the mapping from Person to PersonDto requires some special logic which can’t be generated by
MapStruct. You could then define the mapper from the previous example like this:

```java

@Mapper
public interface CarMapper {

    @Mapping(...)
    ...

    CarDto carToCarDto(Car car);

    default PersonDto personToPersonDto(Person person) {
        //hand-written mapping logic
    }
}
```

## Mapping methods with several source parameters

MapStruct also supports mapping methods with several source parameters. This is useful e.g. in order to combine several
entities into one data transfer object.

```java

@Mapper
public interface AddressMapper {

    @Mapping(target = "description", source = "person.description")
    @Mapping(target = "houseNumber", source = "address.houseNo")
    DeliveryAddressDto personAndAddressToDeliveryAddressDto(Person person, Address address);
}
```

The shown mapping method takes two source parameters and returns a combined target object. As with single-parameter
mapping methods properties are mapped by name.

## Mapping nested bean properties to current target

If you don’t want explicitly name all properties from nested source bean, you can use . as target. This will tell
MapStruct to map every property from source bean to target object.

```java

@Mapper
public interface CustomerMapper {

    @Mapping(target = "name", source = "record.name")
    @Mapping(target = ".", source = "record")
    @Mapping(target = ".", source = "account")
    Customer customerDtoToCustomer(CustomerDto customerDto);
}
```

The generated code will map every property from CustomerDto.record to Customer directly, without need to manually name
any of them. The same goes for Customer.account.

## Updating existing bean instances

In some cases you need mappings which don’t create a new instance of the target type but instead update an existing
instance of that type. This sort of mapping can be realized by adding a parameter for the target object and marking this
parameter with `@MappingTarget`.

```java

@Mapper
public interface CarMapper {

    void updateCarFromDto(CarDto carDto, @MappingTarget Car car);
}
```

The generated code of the updateCarFromDto() method will update the passed Car instance with the properties from the
given CarDto object. There may be only one parameter marked as mapping target. Instead of void you may also set the
method’s return type to the type of the target parameter, which will cause the generated implementation to update the
passed mapping target and return it as well. This allows for fluent invocations of mapping methods.

## Mappings with direct field access

MapStruct also supports mappings of public fields that have no getters/setters. MapStruct will use the fields as
read/write accessor if it cannot find suitable getter/setter methods for the property.

A field is considered as a read accessor if it is public or public final. If a field is static it is not considered as a
read accessor.

A field is considered as a write accessor only if it is public. If a field is final and/or static it is not considered
as a write accessor.

```java
public class Customer {

    private Long id;
    private String name;

    //getters and setter omitted for brevity
}

public class CustomerDto {

    public Long id;
    public String customerName;
}

@Mapper
public interface CustomerMapper {

    CustomerMapper INSTANCE = Mappers.getMapper(CustomerMapper.class);

    @Mapping(target = "name", source = "customerName")
    Customer toCustomer(CustomerDto customerDto);

    @InheritInverseConfiguration
    CustomerDto fromCustomer(Customer customer);
}
```

## Using builders

MapStruct also supports mapping of immutable types via builders. When performing a mapping MapStruct checks if there is
a builder for the type being mapped. This is done via the BuilderProvider SPI. If a Builder exists for a certain type,
then that builder will be used for the mappings.

## Using Constructors

MapStruct supports using constructors for mapping target types. When doing a mapping MapStruct checks if there is a
builder for the type being mapped. If there is no builder, then MapStruct looks for a single accessible constructor.
When there are multiple constructors then the following is done to pick the one which should be used:

- If a constructor is annotated with an annotation named @Default (from any package, see Non-shipped annotations) it
  will be used.

- If a single public constructor exists then it will be used to construct the object, and the other non public
  constructors will be ignored.

- If a parameterless constructor exists then it will be used to construct the object, and the other constructors will be
  ignored.

- If there are multiple eligible constructors then there will be a compilation error due to ambiguous constructors. In
  order to break the ambiguity an annotation named @Default (from any package, see Non-shipped annotations) can used.

## Mapping Map to Bean

There are situations when a mapping from a Map<String, ???> into a specific bean is needed. MapStruct offers a
transparent way of doing such a mapping by using the target bean properties (or defined through Mapping#source) to
extract the values from the map. Such a mapping looks like:

```java
public class Customer {

    private Long id;
    private String name;

    //getters and setter omitted for brevity
}

@Mapper
public interface CustomerMapper {

    @Mapping(target = "name", source = "customerName")
    Customer toCustomer(Map<String, String> map);

}
```

# Data type conversions

Not always a mapped attribute has the same type in the source and target objects. For instance an attribute may be of
type int in the source bean but of type Long in the target bean.

## Implicit type conversions

MapStruct takes care of type conversions automatically in many cases. If for instance an attribute is of type int in the
source bean but of type String in the target bean, the generated code will transparently perform a conversion by calling
String#valueOf(int) and Integer#parseInt(String), respectively.

```java

@Mapper
public interface CarMapper {

    @Mapping(source = "price", numberFormat = "$#.00")
    CarDto carToCarDto(Car car);

    @IterableMapping(numberFormat = "$#.00")
    List<String> prices(List<Integer> prices);
}
```

```java

@Mapper
public interface CarMapper {

    @Mapping(source = "manufacturingDate", dateFormat = "dd.MM.yyyy")
    CarDto carToCarDto(Car car);

    @IterableMapping(dateFormat = "dd.MM.yyyy")
    List<String> stringListToDateList(List<Date> dates);
}
```

## Controlling nested bean mappings

As explained above, MapStruct will generate a method based on the name of the source and target property. Unfortunately,
in many occasions these names do not match.

```java

@Mapper
public interface FishTankMapper {

    @Mapping(target = "fish.kind", source = "fish.type")
    @Mapping(target = "fish.name", ignore = true)
    @Mapping(target = "ornament", source = "interior.ornament")
    @Mapping(target = "material.materialType", source = "material")
    @Mapping(target = "quality.report.organisation.name", source = "quality.report.organisationName")
    FishTankDto map(FishTank source);
}
```

The same constructs can be used to ignore certain properties at a nesting level, as is demonstrated in the second
@Mapping rule.

## Invoking custom mapping method

Sometimes mappings are not straightforward and some fields require custom logic.

The example below demonstrates how the properties length, width and height in FishTank can be mapped to the VolumeDto
bean, which is a member of FishTankWithVolumeDto. VolumeDto contains the properties volume and description. Custom logic
is achieved by defining a method which takes FishTank instance as a parameter and returns a VolumeDto. MapStruct will
take the entire parameter source and generate code to call the custom method mapVolume in order to map the FishTank
object to the target property volume.

```java
public class FishTank {
    Fish fish;
    String material;
    Quality quality;
    int length;
    int width;
    int height;
}

public class FishTankWithVolumeDto {
    FishDto fish;
    MaterialDto material;
    QualityDto quality;
    VolumeDto volume;
}

public class VolumeDto {
    int volume;
    String description;
}

@Mapper
public abstract class FishTankMapperWithVolume {

    @Mapping(target = "fish.kind", source = "source.fish.type")
    @Mapping(target = "material.materialType", source = "source.material")
    @Mapping(target = "quality.document", source = "source.quality.report")
    @Mapping(target = "volume", source = "source")
    abstract FishTankWithVolumeDto map(FishTank source);

    VolumeDto mapVolume(FishTank source) {
        int volume = source.length * source.width * source.height;
        String desc = volume < 100 ? "Small" : "Large";
        return new VolumeDto(volume, desc);
    }
}
```

## Invoking other mappers

In addition to methods defined on the same mapper type MapStruct can also invoke mapping methods defined in other
classes, be it mappers generated by MapStruct or hand-written mapping methods. This can be useful to structure your
mapping code in several classes (e.g. with one mapper type per application module) or if you want to provide custom
mapping logic which can’t be generated by MapStruct.

```java
public class DateMapper {

    public String asString(Date date) {
        return date != null ? new SimpleDateFormat("yyyy-MM-dd")
                .format(date) : null;
    }

    public Date asDate(String date) {
        try {
            return date != null ? new SimpleDateFormat("yyyy-MM-dd")
                    .parse(date) : null;
        } catch (ParseException e) {
            throw new RuntimeException(e);
        }
    }
}
```

```java

@Mapper(uses = DateMapper.class)
public interface CarMapper {

    CarDto carToCarDto(Car car);
}
```

When generating code for the implementation of the carToCarDto() method, MapStruct will look for a method which maps a
Date object into a String, find it on the DateMapper class and generate an invocation of asString() for mapping the
manufacturingDate attribute.

## Passing the mapping target type to custom mappers 

When having a custom mapper hooked into the generated mapper with @Mapper#uses(), an additional parameter of type
Class (or a super-type of it) can be defined in the custom mapping method in order to perform general mapping tasks for
specific target object types. That attribute must be annotated with @TargetType for MapStruct to generate calls that
pass the Class instance representing the corresponding property type of the target bean.

For instance, the CarDto could have a property owner of type Reference that contains the primary key of a Person entity.
You could now create a generic custom mapper that resolves any Reference objects to their corresponding managed JPA
entity instances.

```java
@ApplicationScoped // CDI component model
public class ReferenceMapper {

    @PersistenceContext
    private EntityManager entityManager;

    public <T extends BaseEntity> T resolve(Reference reference, @TargetType Class<T> entityClass) {
        return reference != null ? entityManager.find( entityClass, reference.getPk() ) : null;
    }

    public Reference toReference(BaseEntity entity) {
        return entity != null ? new Reference( entity.getPk() ) : null;
    }
}

@Mapper(componentModel = MappingConstants.ComponentModel.CDI, uses = ReferenceMapper.class )
public interface CarMapper {

    Car carDtoToCar(CarDto carDto);
}
```